* Notes
** Preface
*** Book outline
**** Part I
introduces the Common Lisp

**** Part II
covers four early A1 programs that all use rule-based pattern-matching
techniques.

**** Part III
detours from AI for a moment to present some general tools for more
efficient programming. The reader who masters the material in this part can be
considered an advanced Lisp programmer.

**** Part IV
covers some advanced AI programs.

**** Part V
includes material that is peripheral to AI but important for any serious
Lisp programmer.

*** Most Important For me
For the Professional Lisp Programmer: Read as much of the book as possible, and
refer back to it often. Part III and chapter 25 are particularly important.

*** A Note on Exercises
Sample exercises are provided throughout. Readers can test their level of under-
standing by faithfully doing the exercises. The exercises are graded on the scale [s],
[m], [h], [dl, which can be interpreted either as a level of difficulty or as an expected
time it will take to do the exercise:

| Code | Difficulty | Time to do |
|------+------------+------------|
| [s]  | Simple     | Seconds    |
| [m]  | Medium     | Minutes    |
| [h]  | Hard       | Hours      |
| [d]  | Difficult  | Days       |

The time to do the exercise is measured from the point that the concepts have
been well understood. If the reader is unclear on the underlying concepts, it might
take hours of review to understand a [m] problem. Answers to the exercises can be
found in a separate section at the end of each chapter.

** THE INDEX
PDF page 13

book page = pdf page - 24
** chapter 1
(last list n) last n items
*** the story of lambda
pdf page 44
Russell used ^ above a symbol for bound variables in his Principia Mathematica
Church initially moved ^ to the front of a symbol,
then switched to uppercase version of lambda Λ,
because it was confused with A he eventually switched to lowercase λ,
John McCarthy was student of Church, when he invented Lisp there was
no λ character on the keyboard, so we have lambda
*** sharp-quote
When a function appears at cdr part ot a list use of #' tells lisp evaluator
to treat is a a function instead of eveluating it using normal rules.
you could think of it as #'fn == (function fn)
*** lambda expressions can create functions at runtime
see section 3.16 about closures
*** 1.9 Lisp evaluation
**** expression
***** list
evaluated as:
****** special form expression
a list whose first element is operator
eg. (+ 1 2) 'john (quote john) #'fn (function fn)
+, ', quote, #', and function are operators
****** function application
is evaluated by first evaluating the arguments (the rest of list)
and then finding the functionvnamed by the first element of the list
and applying it to the evaluated arguments
eg. (+ a b)
here we first evaluate variables a & b, then we apply + to them
***** atom
****** symbol
evaluates to most recent value assigned to the variable named by symbol
****** non symbol
evaluates to itself, numbers, strings etc.
**** distinction between reading and evaluating
** chapter 2
*** 2.1
*** 2.2
trace on pdf page 61
(trace list of functions)
(trace)
visited functions listed
*** 2.3
**** defvar vs defparameter
The special forms defvar and defparameter both introduce special variables
and assign a value to them; the difference is that a
variable, like *grammar*, is routinely changed during the course of running
the program.
A parameter, like *simple-grammar*, on the other hand, will normally stay
constant. A change to a parameter is considered a change to the program,
not a change by the program.
**** assoc
CL-USER> (assoc 2 '((1 a) (2 b) (3 c)))
(2 B)

*** 2.4
**** two alternate approaches
***** most straightforward mapping of the problem to code
***** most natural notation available to solve the problem
then write interpreter for the notation

****** cons
******* involves extra step
******* more work for small problems
****** pros
******* usually easier to modify
******* work as much of the problem as possible in its own terms
******* minimise solution written directly in Lisp
*** 2.5
*** 2.6
**** rules and facts representation is easier for multiple purpose use
**** nested sentence structure
**** using STRAIGHTFORWARD FUNCTIONS we would be stuck
we would have to rewrite every function to generate additional structure
**** with new notation we can keep grammar and rewrite just generate function
to produce nested lists.
***** cons the category onto the front of each rewrite
***** do not append results
*** 2.7 Exercises
** chapter 3
*** 3.1
**** six programming maxims
***** be specific
for example when is more specific than if
***** use abstractions
You should not make mistake of invoking primitive functions directly

If you define a list of names:
(defvar *names*
 '((Robert E. Lee) ... ))
then you should also define functions to get at the components of each name.
To get Lee use (last-name (car *names*)) not (caddar *names*)

Use find or find if instead of loop, find is more specific, it is an abstraction.
It is more concise it's built in and it's easier to understand.
****** maxim conflicts
sometimes maxims are in conflict and experience will tell you which one to prefer
in such case remember rule 6: be consistent
***** be concise
***** use the provided tools
***** do not be obscure
***** be consistent
*** 3.2
**** defvar vs defparameter
defvar will be assigned initial value only if it does not have any value
defparameter will always assign supplied value
**** defstruct and default values
**** conditionals
it is considered poor style to use and & or for anything other than testing
a logical condition

When the main purpose is to return value rather than take action
cond & if (with explicit nil) are preferred over when & unless.

| action   | possibilities |
|----------+---------------|
| when     |             1 |
| if, cond |             2 |
| cond     |            3+ |

If there are several tests comparing an expression to constant then case is
appropriate
***** typecase
***** errors
****** ecase etypecase
****** ccase ctypecase
**** variables and places

** last page
79
