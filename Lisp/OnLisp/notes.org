* Chapter 2

** 2.2 Defining Functions
*** defun and setf
page 12
**** symbol-value
The function symbol-value takes a
symbol and returns the value of the corresponding special variable:

**** symbol-function
Beneath the surface, defun is setting the symbol-function of its first argu-
ment to a function constructed from the remaining arguments. The following two
expressions do approximately the same thing:

(defun double (x) (* x 2))

(setf (symbol-function ’double)
  #’(lambda (x) (* x 2)))

** 2.3 Functional Arguments

*** Apply and Funcall
Generally, we call apply
with two arguments: a function, and a list of arguments for it. The following four
expressions all have the same effect:

(+ 1 2)
(apply #’+ ’(1 2))
(apply (symbol-function ’+) ’(1 2))
(apply #’(lambda (x y) (+ x y)) ’(1 2))

In Common Lisp, apply can take any number of arguments, and the function
given first will be applied to the list made by consing the rest of the arguments
onto the list given last. So the expression

(apply #’+ 1 ’(2))

is equivalent to the preceding four. If it is inconvenient to give the arguments as
a list, we can use funcall, which differs from apply only in this respect. This
expression

(funcall #’+ 1 2)

has the same effect as those above.

*** functions as arguments
page 15

Since functions are data objects, a variable can have a function as its
regular value. That’s what’s happening here. Sharp-quote is only for referring
to the function named by a symbol

** 2.4 Functions as Properties
*** cond vs stored function

** 2.5 Scope
The difference between lexical and dynamic scope comes down to how an
implementation deals with free variables. A symbol is bound in an expression
if it has been established as a variable, either by appearing as a parameter, or by
variable-binding operators like let and do. Symbols which are not bound are
said to be free. In this example, scope comes into play:

(let ((y 7))
  (defun scope-test (x)
    (list x y)))

Within the defun expression,x is bound and y is free. Free variables are interesting
because it’s not obvious what their values should be. There’s no uncertainty about
the value of a bound variable—when scope-test is called, the value of x should
be whatever is passed as the argument. But what should be the value of y? This
is the question answered by the dialect’s scope rules.
In a dynamically scoped Lisp, to find the value of a free variable when exe-
cuting scope-test, we look back through the chain of functions that called it.
When we find an environment where y was bound, that binding of y will be the
one used in scope-test. If we find none, we take the global value of y. Thus, in
a dynamically scoped Lisp, y would have the value it had in the calling expression:

(let ((y 5))
  (scope-test 3))
    (3 5)

With dynamic scope, it means nothing that y was bound to 7 when scope-test
was defined. All that matters is that y had a value of 5 when scope-test was
called.
In a lexically scoped Lisp, instead of looking back through the chain of calling
functions, we look back through the containing environments at the time the
function was defined. In a lexically scoped Lisp, our example would catch the
binding of y where scope-test was defined. So this is what would happen in
Common Lisp:

(let ((y 5))
  (scope-test 3))
    (3 7)

Here the binding of y to 5 at the time of the call has no effect on the returned
value.
Though you can still get dynamic scope by declaring a variable to be special,
lexical scope is the default in Common Lisp. On the whole, the Lisp community
seems to view the passing of dynamic scope with little regret. For one thing, it
used to lead to horribly elusive bugs. But lexical scope is more than a way of
avoiding bugs. As the next section will show, it also makes possible some new
programming techniques.

** 2.6 Closures
Because Common Lisp is lexically scoped, when we define a function containing
free variables, the system must save copies of the bindings of those variables at
the time the function was defined. Such a combination of a function and a set
of variable bindings is called a closure.

(defun list+ (lst n)
  (mapcar #’(lambda (x) (+ x n))
    lst))

will do what we want:

(list+ ’(1 2 3) 10)
  (11 12 13)

If we look closely at the function which is passed to mapcar within list+, it’s
actually a closure. The instance of n is free, and its binding comes from the
surrounding environment. Under lexical scope, every such use of a mapping
function causes the creation of a closure.
Closures play a more conspicuous role in a style of programming promoted
by Abelson and Sussman’s classic Structure and Interpretation of Computer Pro-
grams. Closures are functions with local state.

** 2.7 Local Functions
When we define functions with lambda-expressions, we face a restriction which
doesn’t arise with defun: a function defined in a lambda-expression doesn’t have
a name and therefore has no way of referring to itself. This means that in Common
Lisp we can’t use lambda to define a recursive function.

** 2.8 Tail Recursion
A recursive function is one that calls itself. Such a call is tail-recursive if no
work remains to be done in the calling function afterwards. This function is not
tail-recursive

(defun our-length (lst)
  (if (null lst)
    0
    (1+ (our-length (cdr lst)))))

because on returning from the recursive call we have to pass the result to 1+. The
following function is tail-recursive, though

(defun our-find-if (fn lst)
  (if (funcall fn (car lst))
    (car lst)
    (our-find-if fn (cdr lst))))

because the value of the recursive call is immediately returned.

*** optimisation
Many Common Lisp compilers can do tail-recursion optimization, but not all
of them do it by default. So after writing your functions to be tail-recursive, you
may also want to put

(proclaim ’(optimize speed))

at the top of the file, to ensure that the compiler can take advantage of your efforts.
