* Reading fp-made-easier
** Index
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#3

** next reading
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#71

** parts

*** Beginner
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#35

**** 1 Discipline is Freedom

***** 1.1 Global State
#+begin_quote
Many would argue that Object-Oriented Programming solves these problems.
Unfortunately, it does not. It only hides them.
#+end_quote

***** 1.2 Mutable State

***** 1.2.1 No variables
#+begin_quote
An expression is Referentially Transparent if it can be replaced with its value without
changing the program’s behavior.
#+end_quote

***** 1.2.2 No Loops

***** 1.3 Purity

***** 1.4 Optimization

***** 1.4.1 Memoization
#+begin_quote
Bad designs produce unexpected consequences whereas good designs produce
unexpected benefits.
#+end_quote

We can not memoize impure functions

***** 1.4.2 Compiler Optimization

***** 1.5 Types
1.5.1
1.5.2
1.5.3
1.5.4
1.5.5
1.6

**** 2 Power of functions
Java could not pass a function as parameter

***** 2.1 Functions as Parameters

***** 2.2 Functions as Return Values

***** 2.3. Higher-order Functions

***** 2.4. Composition
Domain and Codomain -- in programmer speak Input and Output
#+begin_example
(f (g x)) ; Lisp
f ∘ g (x)
This is spoken as f COMPOSED WITH g APPLIED TO x.
#+end_example

composition and no parameters
#+begin_src purescript
                     -- without composition
  intToStringArray :: Int -> Array String
  intToStringArray n = toArray (toString n)
                       -- with composition
  intToStringArray :: Int -> Array String
  intToStringArray = toArray <<< toString
#+end_src

PureScript also provides the >>> operator when we want to compose in the
opposite direction. This is usually done because the code may read better.
2.4.1. Point-free Notation
#+begin_quote
Point-free notation (or style) means that a Function is defined WITHOUT explicitly
mentioning one or more of its Parameters.
#+end_quote

#+begin_src purescript
  -- with arguments
  zeroPad :: Int -> String -> String
  zeroPad size s = (padLeft '0') size s
  -- poinfree
  zeroPad :: Int -> String -> String
  zeroPad = padLeft '0'
#+end_src

***** 2.5 Currying
lambda calculus as purescript
#+begin_src purescript
  λx. x + 1
  -- In PureScript, we’d write this as:
  \x -> x + 1
#+end_src

currying transforms lambdas
#+begin_src purescript
  \x y -> x + y
  -- and turns it into a Function like:
  \x -> \y -> x + y
#+end_src

similar in lisp
#+begin_src lisp
  (funcall (funcall  (lambda (x) (lambda (y) (list :res x y))) 1) 2)
#+end_src

All Type Signatures have implied Parentheses that are Right-Associative, i.e. associates to the right:
Here we have examples with explicit parentheses
#+begin_src purescript
  add :: Int -> (Int -> Int)
  add x y = x + y
            -- or with 3 arguments
  add3 :: Int -> (Int -> (Int -> Int))
  add3 x y z = x + y + z
#+end_src

how signature changes on adding parameters
#+begin_src purescript
  add3 :: Int -> Int -> Int -> Int
  add3 x y z = x + y + z
  -- When we call add3 with one Parameter:
  add3 1 :: Int -> Int -> Int
  -- x is bound to 1. When we call that resulting Function with one Parameter:
  (add3 1) 2 :: Int -> Int
  -- y gets bound to 2. Calling that resulting Function with one Parameter:
  ((add3 1) 2) 3 :: Int
#+end_src

2.5.1. Partial Application
#+begin_quote
Partial Application is when a Function is called with fewer than all of its Parameters.
#+end_quote

When we think of Functions having multiple Parameters, then Partial Application makes sense. However,
when we think of Curried Functions, there is no such thing as Partial Application since there’s only one
Parameter.

I like to think of Partial Application as configuring a more general Function.
We’re sort of baking in the configuration Values.

JP Adding subsequent parameters specialises the final function
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#71

It’s worth spending some time planning the order of your Parameters for this very reason.

#+begin_quote
The general rule for Parametric Order is to have the Parameters that change the least be
the leftmost ones and the ones that change the most to be rightmost.
#+end_quote

**** 3 The Basics of PureScript

***** 3.1 Types
Most of PureScript’s code is open source and can easily be perused via the
GitHub repositories, but the implementation for Primitive Types are built into
the compiler, which is written in Haskell.
3.1.1. Javascript Primitives
The following Primitive Types map directly to Javascript’s types:
• Boolean
• Char
• String
• Number

***** 3.1.2 Purescript Primitives
These are the PureScript-specific primitives, i.e. they don’t map directly to Javascript’s types:
• Int
• Array
• Record

Nested Array
#+begin_src purescript
aa :: Array (Array Int)
aa = [ [1, 2, 3], [4, 5], [6, 7, 8, 9] ]
#+end_src

Record
#+begin_src purescript
  -- declaration
  r :: { firstName :: String, lastName :: String }
  -- construction
  r = { firstName: "Joe", lastName: "Mama" }
#+end_src

Difference from Elm

To create a Record, we use the following syntax:
#+begin_src purescript
person = { name: "Candy Cane", age: 37 }
#+end_src

To modify a one or more elements in the Record and return a new Record (remember,
all Values are immutable), we use the following syntax:

#+begin_src purescript
newPerson = person { name = "Randy Cane" }
#+end_src

This is the ONLY time an equal sign is used in Record syntax. All other times, a
colon is used.

***** 3.1.3. User Types
PureScript comes with many useful built-in Types but without the ability to make
your own Types, you won’t be able to model your problem domain. PureScript has
the following facilities for defining your own Types:

In PureScript, Data Types and Data Constructors always start with an uppercase
letter, whereas variables start with a lowercase letter or an underscore:

****** Type Alias
like Elm type alias
#+begin_src purescript
    type Id = String
    type Message = { id :: Id, payload :: String }
                   -- but this allows shortcut for more complex type signatures
    type MessageHandler = Message -> Result
    -- so we can have type signature
    handler :: MessageHandler
             -- instead of
    handler' :: Message -> Result
#+end_src

****** Data Type
#+begin_src purescript
data MyType = MyType
#+end_src
Here we define a type and its constructor

The namespace for Data Types and Data Constructors are separate so there is no
name collision here.

****** Algebraic Data Types
If the calculation involves a multiplication then it’s a Product Type. If it
involves addition then it’s a CoProduct Type or Sum Type.

In Math, the prefix *co* is added to mean the opposite (Domain, Codomain, Sine,
Cosine, Tangent, Cotangent, etc.).

******* Product Type
Product types are data types, defined through more than just one constructor as
in tuples or records

my guess
#+begin_src purescript
  data Season = Spring | Summer | Autumn | Winter
  data Boolish = (Bool, Season)
#+end_src

Here we multiply 2 booleans times 4 Season values, getting 8 combinations.

also see [[*Product Types - with parameters][Product Types - with parameters]]

******* Coproduct or Sum Type
#+begin_src purescript
data Bool = True | False
#+end_src

******* type variables
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#80

******* Polymorphic vs Monomorphic
monomorphic takes no type parameters, polymorphic is a declaration with type
parameters

******** Product Types - with parameters
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#81
#+begin_src purescript
data Triplet a b c = Triplet a b c
#+end_src

Here we have a 3 Polymorphic Type Parameters, a, b and c.
The Data Constructor, Triplet has the implied Type:
#+begin_src purescript
Triplet :: a -> b -> c -> Triplet
#+end_src

Let’s create a Triplet:
#+begin_src purescript
type StringStats = Triplet String Int Int
getStats :: String -> StringStats
getStats s = Triplet s (length s) (vowelCount s)
#+end_src

StringStats simultaneously contains 1 String and 2 Integers. That’s what makes it a Product Type. It contains a String AND an Int AND another Int.

In sets, this corresponds to Intersection. The intersection of Set A and Set B
contains elements that are contained in A AND contained in B.

******* Isomorphic
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#83

Comparing our Triplet to StringStats:
#+begin_src purescript
data Triplet a b c = Triplet a b c
data StringStats = StringStats
{ string :: String
, length :: Int
, vowelCount :: Int
}
#+end_src

StringStats and Triplet both contain the same information. The big difference is
the fact that Triplet is more flexible since it can take any types a, b and c,
whereas StringStats takes very specific types String, Int and Int: They’re
almost the same, but let’s work to make them closer. First, let’s make a
specialized version of Triplet:
#+begin_src purescript
data StringTriplet = StringTriplet String Int Int
data StringStats = StringStats
{ string :: String
, length :: Int
, vowelCount :: Int
}
#+end_src
Now StringTriplet and StringStats have exactly the same types.

#+begin_quote
Two Types, T1 and T2, are Isomorphic (Iso means equal and morph means shape) if a
Function can be written from T1 to T2 and from T2 to T1 without any loss of information.
#+end_quote

******** Inhabitants
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#84

The NO information loss part of Isomorphisms is very important. At first glance,
you might think String and Int are Isomorphic since any Int can be converted
into a String. But not any String can be converted into an Int.

Types are similar to Sets, except where Sets have Elements, Types have
Inhabitants. And there are far more Inhabitants of String than Int even though
they both have an Infinite number of Inhabitants.

Let’s imagine a Type that only contains the numbers 42 and 79 and let’s call it
TwoNum. Because this has two inhabitants, it makes it Isomorphic to Boolean
since it also has two inhabitants, true and false.

#+begin_quote
Any two types with an equal number Inhabitants are Isomorphic.
#+end_quote

****** New Type
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#87

progressing with fullName function
starting the signature with String parameters
#+begin_src purescript
  fullName :: String -> String -> String -> String
#+end_src
we can see the problem with this approach where we will not get type warning
when we confuse the order of parameters

then trying type aliases
#+begin_src purescript
type FirstName = String
type MiddleName = String
type LastName = String
fullName :: FirstName -> MiddleName -> LastName -> String
#+end_src
but the type aliases are only helpful when the programmer reads them

so let's try unique types for each parameter
*New Types*
#+begin_src purescript
data FirstName = FirstName String
data MiddleName = MiddleName String
data LastName = LastName String
data FullName = FullName String
fullName :: FirstName -> MiddleName -> LastName -> FullName
#+end_src

Now let’s call our Function with our new Types:
#+begin_src purescript
-- COMPILER ERROR!
fullName (LastName "Smith") (MiddleName "Jay") (FirstName "John")
#+end_src
We called fullName with the Parameters in the wrong order again. But this time,
we get a compiler error because even though FirstName and LastName both take
Strings, they are not the same Type anymore.

This technique just wraps a Type inside of another Type. In our case, we wrapped
our String in another Type which made it unique. We essentially made a new Type
for each String in our original Function.

PureScript has a special keyword for this approach called newtype:
#+begin_src purescript
newtype FirstName = FirstName String
newtype MiddleName = MiddleName String
newtype LastName = LastName String
newtype FullName = FullName String
fullName :: FirstName -> MiddleName -> LastName -> FullName
fullName (FirstName first) (MiddleName middle) (LastName last) =
FullName (first <> " " <> middle <> " " <> last)
#+end_src
data has been replaced with newtype

The newtype keyword tells the compiler that we’re just making a new Type for
another Type, e.g. FirstName is a new Type for String. That means that the
compiler can do some optimizations if it knows that it’s just a simple wrapper.

But it can only do these optimizations if certain restrictions are imposed:
• newtypes must only have 1 Data Constructor
• The Data Constructor can only take 1 Parameter

There will be more about the newtypes discussed in *typeclasses*

***** 3.1.4. Common Library Types
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#89


#+begin_src purescript
#+end_src

pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#89



*** Intermediate
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#234

*** Advanced
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#543

*** Beyond
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#1000
