* Reading fp-made-easier
** Index
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#3

** next reading
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#71

** parts

*** Beginner
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#35

**** 1 Discipline is Freedom

***** 1.1 Global State
#+begin_quote
Many would argue that Object-Oriented Programming solves these problems.
Unfortunately, it does not. It only hides them.
#+end_quote

***** 1.2 Mutable State

***** 1.2.1 No variables
#+begin_quote
An expression is Referentially Transparent if it can be replaced with its value without
changing the program’s behavior.
#+end_quote

***** 1.2.2 No Loops

***** 1.3 Purity

***** 1.4 Optimization

***** 1.4.1 Memoization
#+begin_quote
Bad designs produce unexpected consequences whereas good designs produce
unexpected benefits.
#+end_quote

We can not memoize impure functions

***** 1.4.2 Compiler Optimization

***** 1.5 Types
1.5.1
1.5.2
1.5.3
1.5.4
1.5.5
1.6

**** 2 Power of functions
Java could not pass a function as parameter

***** 2.1 Functions as Parameters

***** 2.2 Functions as Return Values

***** 2.3. Higher-order Functions

***** 2.4. Composition
Domain and Codomain -- in programmer speak Input and Output
#+begin_example
(f (g x)) ; Lisp
f ∘ g (x)
This is spoken as f COMPOSED WITH g APPLIED TO x.
#+end_example

composition and no parameters
#+begin_src purescript
                     -- without composition
  intToStringArray :: Int -> Array String
  intToStringArray n = toArray (toString n)
                       -- with composition
  intToStringArray :: Int -> Array String
  intToStringArray = toArray <<< toString
#+end_src

PureScript also provides the >>> operator when we want to compose in the
opposite direction. This is usually done because the code may read better.
2.4.1. Point-free Notation
#+begin_quote
Point-free notation (or style) means that a Function is defined WITHOUT explicitly
mentioning one or more of its Parameters.
#+end_quote

#+begin_src purescript
  -- with arguments
  zeroPad :: Int -> String -> String
  zeroPad size s = (padLeft '0') size s
  -- poinfree
  zeroPad :: Int -> String -> String
  zeroPad = padLeft '0'
#+end_src

***** 2.5 Currying
lambda calculus as purescript
#+begin_src purescript
  λx. x + 1
  -- In PureScript, we’d write this as:
  \x -> x + 1
#+end_src

currying transforms lambdas
#+begin_src purescript
  \x y -> x + y
  -- and turns it into a Function like:
  \x -> \y -> x + y
#+end_src

similar in lisp
#+begin_src lisp
  (funcall (funcall  (lambda (x) (lambda (y) (list :res x y))) 1) 2)
#+end_src

All Type Signatures have implied Parentheses that are Right-Associative, i.e. associates to the right:
Here we have examples with explicit parentheses
#+begin_src purescript
  add :: Int -> (Int -> Int)
  add x y = x + y
            -- or with 3 arguments
  add3 :: Int -> (Int -> (Int -> Int))
  add3 x y z = x + y + z
#+end_src

how signature changes on adding parameters
#+begin_src purescript
  add3 :: Int -> Int -> Int -> Int
  add3 x y z = x + y + z
  -- When we call add3 with one Parameter:
  add3 1 :: Int -> Int -> Int
  -- x is bound to 1. When we call that resulting Function with one Parameter:
  (add3 1) 2 :: Int -> Int
  -- y gets bound to 2. Calling that resulting Function with one Parameter:
  ((add3 1) 2) 3 :: Int
#+end_src

2.5.1. Partial Application
#+begin_quote
Partial Application is when a Function is called with fewer than all of its Parameters.
#+end_quote

When we think of Functions having multiple Parameters, then Partial Application makes sense. However,
when we think of Curried Functions, there is no such thing as Partial Application since there’s only one
Parameter.

I like to think of Partial Application as configuring a more general Function.
We’re sort of baking in the configuration Values.

JP Adding subsequent parameters specialises the final function
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#71

It’s worth spending some time planning the order of your Parameters for this very reason.

#+begin_quote
The general rule for Parametric Order is to have the Parameters that change the least be
the leftmost ones and the ones that change the most to be rightmost.
#+end_quote

**** 3 The Basics of PureScript

***** 3.1 Types
Most of PureScript’s code is open source and can easily be perused via the
GitHub repositories, but the implementation for Primitive Types are built into
the compiler, which is written in Haskell.
3.1.1. Javascript Primitives
The following Primitive Types map directly to Javascript’s types:
• Boolean
• Char
• String
• Number

***** 3.1.2 Purescript Primitives
These are the PureScript-specific primitives, i.e. they don’t map directly to Javascript’s types:
• Int
• Array
• Record

Nested Array
#+begin_src purescript
aa :: Array (Array Int)
aa = [ [1, 2, 3], [4, 5], [6, 7, 8, 9] ]
#+end_src

Record
#+begin_src purescript
  -- declaration
  r :: { firstName :: String, lastName :: String }
  -- construction
  r = { firstName: "Joe", lastName: "Mama" }
#+end_src

Difference from Elm

To create a Record, we use the following syntax:
#+begin_src purescript
person = { name: "Candy Cane", age: 37 }
#+end_src

To modify a one or more elements in the Record and return a new Record (remember,
all Values are immutable), we use the following syntax:

#+begin_src purescript
newPerson = person { name = "Randy Cane" }
#+end_src

This is the ONLY time an equal sign is used in Record syntax. All other times, a
colon is used.

***** 3.1.3. User Types

pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#77



*** Intermediate
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#234

*** Advanced
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#543

*** Beyond
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#1000
