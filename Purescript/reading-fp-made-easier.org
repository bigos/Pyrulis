* Reading fp-made-easier
** Index
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#3

** next reading
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#62


** parts

*** Beginner
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#35

**** 1 Discipline is Freedom
1.1 Global State
#+begin_quote
Many would argue that Object-Oriented Programming solves these problems.
Unfortunately, it does not. It only hides them.
#+end_quote

1.2 Mutable State
1.2.1 No variables
#+begin_quote
An expression is Referentially Transparent if it can be replaced with its value without
changing the program’s behavior.
#+end_quote
1.2.2 No Loops
1.3 Purity
1.4 Optimization
1.4.1 Memoization
#+begin_quote
Bad designs produce unexpected consequences whereas good designs produce
unexpected benefits.
#+end_quote

We can not memoize impure functions
1.4.2 Compiler Optimization
1.5 Types
1.5.1
1.5.2
1.5.3
1.5.4
1.5.5
1.6

**** 2 Power of functions
Java could not pass a function as parameter
2.1 Functions as Parameters
2.2 Functions as Return Values
2.3. Higher-order Functions
2.4. Composition
Domain and Codomain -- in programmer speak Input and Output
#+begin_example
(f (g x)) ; Lisp
f ∘ g (x)
This is spoken as f COMPOSED WITH g APPLIED TO x.
#+end_example

composition and no parameters
#+begin_src purescript
                     -- without composition
  intToStringArray :: Int -> Array String
  intToStringArray n = toArray (toString n)
                       -- with composition
  intToStringArray :: Int -> Array String
  intToStringArray = toArray <<< toString
#+end_src

PureScript also provides the >>> operator when we want to compose in the
opposite direction. This is usually done because the code may read better.
2.4.1. Point-free Notation
#+begin_quote
Point-free notation (or style) means that a Function is defined WITHOUT explicitly
mentioning one or more of its Parameters.
#+end_quote

#+begin_src purescript
  -- with arguments
  zeroPad :: Int -> String -> String
  zeroPad size s = (padLeft '0') size s
  -- poinfree
  zeroPad :: Int -> String -> String
  zeroPad = padLeft '0'
#+end_src

2.5 Currying
lambda calculus as purescript
#+begin_src purescript
  λx. x + 1
  -- In PureScript, we’d write this as:
  \x -> x + 1
#+end_src

currying transforms lambdas
#+begin_src purescript
  \x y -> x + y
  -- and turns it into a Function like:
  \x -> \y -> x + y
#+end_src

similar in lisp
#+begin_src lisp
  (funcall  (funcall  (lambda (x) (lambda (y) (list :res x y))) 1) 2)
#+end_src

All Type Signatures have implied Parentheses that are Right-Associative, i.e. associates to the right:
Here we have examples with explicit parentheses
#+begin_src purescript
  add :: Int -> (Int -> Int)
  add x y = x + y
            -- or with 3 arguments
  add3 :: Int -> (Int -> (Int -> Int))
  add3 x y z = x + y + z
#+end_src

how signature changes on adding parameters
#+begin_src purescript
  add3 :: Int -> Int -> Int -> Int
  add3 x y z = x + y + z
  -- When we call add3 with one Parameter:
  add3 1 :: Int -> Int -> Int
  -- x is bound to 1. When we call that resulting Function with one Parameter:
  (add3 1) 2 :: Int -> Int
  -- y gets bound to 2. Calling that resulting Function with one Parameter:
  ((add3 1) 2) 3 :: Int
#+end_src

2.5.1. Partial Application



pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#68


2.5.1. Partial Application


*** Intermediate
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#234

*** Advanced
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#543

*** Beyond
pdf:/home/jacek/Documents/Manuals/Purescript/fp-made-easier.pdf#1000
