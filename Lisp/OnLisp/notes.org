* Chapter 2

** 2.2 Defining Functions
*** defun and setf
page 12
**** symbol-value
The function symbol-value takes a
symbol and returns the value of the corresponding special variable:

**** symbol-function
Beneath the surface, defun is setting the symbol-function of its first argu-
ment to a function constructed from the remaining arguments. The following two
expressions do approximately the same thing:

(defun double (x) (* x 2))

(setf (symbol-function ’double)
  #’(lambda (x) (* x 2)))

** 2.3 Functional Arguments

*** Apply and Funcall
Generally, we call apply
with two arguments: a function, and a list of arguments for it. The following four
expressions all have the same effect:

(+ 1 2)
(apply #’+ ’(1 2))
(apply (symbol-function ’+) ’(1 2))
(apply #’(lambda (x y) (+ x y)) ’(1 2))

In Common Lisp, apply can take any number of arguments, and the function
given first will be applied to the list made by consing the rest of the arguments
onto the list given last. So the expression

(apply #’+ 1 ’(2))

is equivalent to the preceding four. If it is inconvenient to give the arguments as
a list, we can use funcall, which differs from apply only in this respect. This
expression

(funcall #’+ 1 2)

has the same effect as those above.

*** functions as arguments
page 15

Since functions are data objects, a variable can have a function as its
regular value. That’s what’s happening here. Sharp-quote is only for referring
to the function named by a symbol

** 2.4 Functions as Properties
*** cond vs stored function


** Scope
The difference between lexical and dynamic scope comes down to how an
implementation deals with free variables. A symbol is bound in an expression
if it has been established as a variable, either by appearing as a parameter, or by
variable-binding operators like let and do. Symbols which are not bound are
said to be free. In this example, scope comes into play:

(let ((y 7))
  (defun scope-test (x)
    (list x y)))

Within the defun expression,x is bound and y is free. Free variables are interesting
because it’s not obvious what their values should be. There’s no uncertainty about
the value of a bound variable—when scope-test is called, the value of x should
