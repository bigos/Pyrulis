* Interesting Notes

* Chapter 2
** Associativity and Precedence
pages 13, 14, 15
infilxl, infixr

** 2.6 Declaring values
The order of declarations in a source code file doesn’t matter because GHCi
loads the entire file at once, so it knows all the values that have been
specified, no matter what order they appear in.

On the other hand, when
you enter them one-by-one into the REPL, the order does matter.

** 2.7 Arithmetic functions in Haskell

| operator | name      | purpose                               |
|----------+-----------+---------------------------------------|
| +        | plus      | addition                              |
| *        | asterisk  | multiplication                        |
| /        | slash     | fractional division                   |
| div      | divide    | integral division, round down         |
| mod      | modulo    | remainder after division              |
| quot     | quotient  | integral division, round towards zero |
| rem      | remainder | remainder after division              |

** 2.7 Negative Numbers
Prelude> 1000 + (-9)
991

** Parenthesizing infix functions
There are times when you want to refer to an infix function without applying
any arguments, and there are also times when you want to use them as
prefix operators instead of infix. In both cases you must wrap the operator
in parentheses.

(+1) is the same addition function but with one argument applied, making
it return the next argument it’s applied to plus one:
Prelude> 1 + 2
Prelude> (+) 1 2
Prelude> (+1) 2

** 2.10 for quotients and remainders
(quot x y)*y + (rem x y) == x
(div x y)*y + (mod x y) == x

** 2.11 Evaluation
When we talk about reducing an expression, we’re talking about evaluating
the terms until it reaches its simplest form. Once a term has reached its
simplest form, we say that it is irreducible or finished evaluating. Usually,
we call this a value. Haskell uses a non-strict evaluation (sometimes called
“lazy evaluation”) strategy which defers evaluation of terms until they’re
forced by other terms referring to them.

** 2.12 Let and where
We can use let and where to introduce names for expressions.

printInc n = print plusTwo
where plusTwo = n + 2

same

printInc2 n = let plusTwo = n + 2
in print plusTwo

*** Intermission: Exercises

*** The lambdas beneath let expressions
Prelude> (\x -> x) 1
1

-- ((lambda (x) x) 1)
-- 1

** 2.13 Chapter Exercises
*** $ Operator
The ($) operator
is a convenience for when you want to express something with fewer pairs
of parentheses.
Example of ($) in some expressions:

Prelude> (2^) $ 2 + 2
16
Prelude> (2^) (2 + 2)
16
Prelude> (2^) 2 + 2
6

If you like, a way to understand ($) in words is: “evaluate everything to
the right of me first.”
Also note that you can stack up multiple uses of ($) in the same expression.
For example, this works:

Prelude> (2^) $ (+2) $ 3*2
256

But this does not:
Prelude> (2^) $ 2 + 2 $ (*30)
-- A rather long and ugly type error about trying to
-- use numbers as if they were functions follows.

We can see for ourselves why this code doesn’t make sense if we examine
the reduction steps.

** 2.14 Definitions
** 2.15 Follow-up resources


* Chapter 3
** 3.1 Printing strings
** 3.2 A first look at types


checking value's type in ghci:
Prelude> :t 'a'
'a' :: Char

** 3.3 Printing simple strings

Prelude> print "hello world!"
"hello world!"

*** printing commands discussed
print
putStrLn
putStr

*** paragraph The main function
*** String concatenation
*** Global versus local definitions
Here’s an example for review:

module GlobalLocal where
topLevelFunction :: Integer -> Integer
topLevelFunction x = x + woot + topLevelValue
where woot :: Integer
woot = 10

topLevelValue :: Integer
topLevelValue = 5

In the above, you could import and use topLevelFunction or
topLevelValue from another module. However, woot is effectively invisible
outside of topLevelFunction. The where and let clauses in Haskell intro-
duce local bindings or declarations. To bind or declare something means to
give an expression a name. You could pass around and use an anonymous
version of topLevelFunction manually, but giving it a name and reusing
it by that name is more pleasant and less repetitious. Also note we explic-
itly declared the type of woot in the where clause. This wasn’t necessary
(Haskell’s type inference would’ve figured it out fine), but it was done here
to show you how in case you need to.

*** Intermission: Exercises

** 3.4 Type signatures of concatenation functions
Everything after the :: is about our types, not our values.
*** Intermission: Exercises
** 3.5 An example of concatenation and scoping
** 3.6 More list functions
** 3.7 Chapter Exercises
** 3.8 Definitions


* new book

** 1.1 All you need is Lambda
finished all you need is lambda

* Chapter 4
** 4.1 Basic Datatypes
** 4.2 Anatomy of a data declaration
** 4.3 Numeric types

*** Integral
**** Int
has minimum and maximum
**** Integer
arbitrarily large

**** minBound maxBound functions
*** Fractional
**** Float
***** single precision
***** violates assumptions
***** generally, not for use in business applications

**** Double
***** twice as many bits as Float

**** Rational
***** arbitrarily precise
***** not as efficient as Scientific

**** Scientific
***** space efficient
***** almost arbitrary precision
***** exponent as Int
****** potential, though unlikely maximum limit

*** all are instances of typeclass Num
*** typeclasses add functionality to types
**** Num tepeclass provides + - * and other operators
**** any type that is instance of Num can be used with those operators
*** typeclass constraint =>
**** (/) :: Fractional a => a -> a -> a
**** The notation Fractional a => denotes a typeclass constraint
This type information is telling us that whatever type of number a turns
out to be, it must be a type that has an instance of the Fractional typeclass.

So (+) and other functions
from the Num typeclass can be used with Fractional numbers, but functions
from the Fractional typeclass cannot be used with all instances of Num


** 4.4 Comparing values

** 4.5 Tuples

** 4.6 Lists

** 4.7 Exercises
*** exercises 2 and 3 on page 143 do not make sense
made sense on page 149
** 4.8 Definitions
** 4.9 Answers
* Chapter 5
** 5.1 Types
** 5.2 What are types
** 5.3 Querying and Reading Types
** 5.4 Typeclass-constrained variables
** 5.5 Currying
*** my Haskell clarification notes

-- p161

As stated earlier, arguments (plural) is a shorthand for the truth in Haskell.
All functions in Haskell take one argument and return one result.

-- p162

(+) :: Num a => a -> a -> a
      /    1   /   2   / 3 /

1. Typeclass constraint saying that a must have an instance of Num.

2. The boundaries of 2 demarcate what you might call the two “arguments” to
the function (+), but really, all functions in Haskell take one argument and
return one result.

This is because functions in Haskell are nested like
Matryoshka dolls in order to accept “multiple” arguments. The nesting is more
apparent when one realizes that (->) is the type constructor for functions and
that a -> a -> a represents successive function applications, each taking one
argument and returning one result. The difference is that the function at the
outermost layer is actually returning another function that accepts the next
argument. This is called currying.

3. The result type for this function.

-- p163

You can nest more lambdas than two, of course, but the process
is the same: one argument, one result, even though that result may be a
function awaiting application to another argument.

--

Let’s kick around currying a bit to see what it does for us:

addStuff :: Integer -> Integer -> Integer
addStuff a b = a + b + 5

So, addStuff appears to take two Integer arguments and return an Integer
result. But after loading that in GHCi we see that it is taking one argument
and returning a function that takes one argument and returns one result:

-- p 164

The ability to apply only some of a function’s arguments is described as
partial application. This lets us reuse addStuff and create a new function
from it with one of the arguments applied.

When one considers that (->) is a type constructor and associates to the
right, this becomes more clear.

addStuff :: Integer -> Integer -> Integer
-- but with explicit parenthesization
addStuff :: Integer -> (Integer -> Integer)

The way you can read the explicitly parenthesized type for addStuff is, “I
take an Integer argument and return a function that takes an Integer and
returns an Integer”. You saw this in action when we partially applied the
addStuff function above.

*** Binding variables to types

-- p164
Let’s next look at an example of the effect that binding arguments has on
types. We will declare a function with a number of arguments that share
the same type, but don’t get used:

-- p165
funcIgnoresArgs :: a -> a -> a -> String
funcIgnoresArgs x y z = "Blah"
Then we load this and apply the first argument in a few different ways to
see what happens:
Prelude> :t funcIgnoresArgs

--
The function a
-> a -> a -> String is only conceptually, but not actually one function.
Technically it’s 3 functions nested one inside another. We could read it as a
-> (a -> (a -> String)). One way to know how many function objects
there are is by their type constructors, and (->) is the type constructor for
functions.

Let’s run this same function through some drills to see what is
meant.
-- `undefined' can pretend to be any type
-- put differently, inhabits all types
Prelude> :t undefined
undefined :: t
Prelude> let u = undefined
Prelude> :t funcIgnoresArgs u
funcIgnoresArgs undefined :: a -> a -> String
Prelude> :t funcIgnoresArgs u u
funcIgnoresArgs u u :: a -> String
Prelude> :t funcIgnoresArgs u u u
funcIgnoresArgs u u u :: String
Prelude> funcIgnoresArgs u u u
"Blah"CHAPTER 5.

*** Manual currying and Uncurry
Haskell is curried by default, but you can uncurry functions. “Uncurrying”
means un-nesting the functions and replacing the two functions with a tuple
of two values (these would be the two values you want to use as arguments).

-- p168
examples on page 168

This means functions
that seem to accept multiple arguments such as with a -> a -> a -> a
are really higher-order functions: they yield more function values as each
argument is applied until there are no more (->) type constructors and it
terminates in a non-function value.

*** Intermission: Exercises

** 5.6 Polymorphism
* continue on page 168
