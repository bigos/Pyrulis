* Readme

** the tutorial
https://en.wikibooks.org/wiki/C_Programming

** excercises

https://en.wikibooks.org/wiki/C_Programming

*** Beginning C

**** hello, Intro Exercise
https://en.wikibooks.org/wiki/C_Programming/Intro_exercise
file:~/Programming/Pyrulis/C/wikibooks/hello.c::1

**** Preliminaries
https://en.wikibooks.org/wiki/C_Programming/Preliminaries

***** blocks
and variable shadowing?

#+begin_src c
int main(void)
{
    /* this is a 'block' */
    int i = 5;

    {
        /* this is also a 'block', nested inside the outer block */
        int i = 6;
    }

    return 0;
}
#+end_src

***** Whitespace

#+begin_src c
  printf("Hello world"); return 0;

  // is the same as

  printf("Hello world");
  return 0;

  // which is also the same as

  printf (
      "Hello world") ;



  return 0;
#+end_src

***** Scope

****** global and local

#+begin_src c
  int i = 5; /* this is a 'global' variable, it can be accessed from anywhere in the program */

  /* this is a function, all variables inside of it
     are "local" to the function. */
  int main(void)
  {
      int i = 6; /* 'i' now equals 6 */
      printf("%d\n", i); /* prints a '6' to the screen, instead of the global variable of 'i', which is 5 */

      return 0;
  }
#+end_src

****** variable shadowing
local variable shadowing

#+begin_src c
  /* the main function */
  int main(void)
  {
      /* this is the beginning of a 'block', you read about those above */

      int i = 6; /* this is the first variable of this 'block', 'i' */

      {
          /* this is a new 'block', and because it's a different block, it has its own scope */

          /* this is also a variable called 'i', but in a different 'block',
             because it's in a different 'block' than the first variable named 'i', it doesn't affect the first one! */
          int i = 5;
          printf("%d\n", i); /* prints a '5' onto the screen */
      }
      /* now we're back into the first block */

      printf("%d\n", i); /* prints a '6' onto the screen */

      return 0;
  }
#+end_src

**** Basics of Compilation
https://en.wikibooks.org/wiki/C_Programming/Basics_of_compilation

Compilation process steps

***** Preprocessor
First the file is preprocessed

All preprocessor directives begin with the hash character ~#~. You can see one
preprocessor directive in the Hello world program. Example:

#+begin_src c
 #include <stdio.h>
#+end_src

***** Syntax check

***** Compiling object code

***** Linking

***** Automation
Makefiles and IDEs

**** Structure and style
https://en.wikibooks.org/wiki/C_Programming/Structure_and_style

***** introduction
In C, programs are composed of statements. Statements are terminated with
a semi-colon,

***** line breaks
While you could in theory put everything in one line, only separated by
a semi-colon it is better to break up code into readable lines.

***** blank lines
Blank lines should be used to offset the main components of your code. Always use them:

+ After preprocessor directives.
+ After new variables are declared.
+ Use your own judgment for finding other places where components should be separated.

***** Indentation
Although adding simple line breaks between key blocks of code can make code
easier to read, it provides no information about the block structure of the
program.

Indentation visually separates paths of execution by moving their starting
points to a new column. This simple practice will make it much easier to read
and understand code.

***** Comments
Two styles of comments ~// style1~ and ~/* style2  */~


**** Variables
https://en.wikibooks.org/wiki/C_Programming/Variables

This is the first meaty part

***** Declaring
#+begin_src c
int some_number;
int anumber, anothernumber, yetanothernumber;
#+end_src

***** Initialising
#+begin_src c
int some_new_number = 4;
#+end_src

***** Assigning
#+begin_src c
some_number = some_new_number;
#+end_src

***** Naming variables
Variable names in C are made up of letters (upper and lower case) and digits.
The underscore character ("_") is also permitted. Names must not begin with a
digit.

***** Literals
Anytime within a program in which you specify a value explicitly instead of
referring to a variable or some other form of data, that value is referred to as
a literal. In the initialization example above [[*Initialising][Initialising]] , 4 is a literal.

***** Four basic data types
In Standard C there are four basic data types. They are int, char, float, and double.

****** int
An integer is typically the size of one machine word, which on most modern home PCs is 32 bits

****** char
It stores the same kind of data as an int (i.e. integers), but typically has a
size of one byte. The size of a byte is specified by the macro CHAR_BIT which
specifies the number of bits in a char (byte). In standard C it never can be
less than 8 bits.

#+begin_src c
char letter1 = 'a';
char letter2 = 97; /* in ASCII, 97 = 'a' */
#+end_src

The first example is a good programming practice in that it allows a person
reading your code to understand that letter1 is being initialized with the
letter 'a' to start off with.

The second way, which should not be used when you are coding letter characters, is to write:

This is considered by some to be extremely bad practice, if we are using it to
store a character, not a small number, in that if someone reads your code, most
readers are forced to look up what character corresponds with the number 97 in
the encoding scheme. In the end, letter1 and letter2 store both the same thing –
the letter 'a', but the first method is clearer, easier to debug, and much more
straightforward.

****** float
Kind of deprecated, it may be better to use doubles consistently.

float variables can be declared using the float keyword. A float is only one
machine word in size. Therefore, it is used when less precision than a double
provides is required.

****** double
double keyword allows you to store double-precision floating point numbers –
real numbers, in other words. Its size is typically two machine words, or 8
bytes on most machines. Examples of double literals are 3.1415926535897932, 4.0,
6.022e+23 (scientific notation). If you use 4 instead of 4.0, the 4 will be
interpreted as an int.

***** sizeof
If you have any doubts as to the amount of memory actually used by any variable
you can use the sizeof operator to find out for sure.

Here we have two types of use.

#+begin_src c
sizeof object
sizeof(type)
#+end_src

***** Data type modifiers

****** long
typically 4 or 8 byte int
some compilers have long long which is 8 bytes

****** short
typically 2 byte int

****** signed
seldom used, because all types except char are signed by default

****** unsigned
if you believe your variable will never be negative you can save one bit in int representation

***** const
variable must be initialised and never be changed

***** magic numbers
better to use const than hardcoded values as 99 can mean many different things
and const allows to name values

****** #define
resembles editor find and replace
has no regard for type or structure

good convention to write its value in all CAPITALS

***** TODO scope

**** TODO Simple Input and Output
**** zzz


*** Intermediate C

*** Advanced C

*** C and Beyond
