* Interesting Notes

* Chapter 2
** Associativity and Precedence
pages 13, 14, 15
infilxl, infixr

** 2.6 Declaring values
The order of declarations in a source code file doesn’t matter because GHCi
loads the entire file at once, so it knows all the values that have been
specified, no matter what order they appear in.

On the other hand, when
you enter them one-by-one into the REPL, the order does matter.

** 2.7 Arithmetic functions in Haskell

| operator | name      | purpose                               |
|----------+-----------+---------------------------------------|
| +        | plus      | addition                              |
| *        | asterisk  | multiplication                        |
| /        | slash     | fractional division                   |
| div      | divide    | integral division, round down         |
| mod      | modulo    | remainder after division              |
| quot     | quotient  | integral division, round towards zero |
| rem      | remainder | remainder after division              |

** 2.7 Negative Numbers
Prelude> 1000 + (-9)
991

** Parenthesizing infix functions
There are times when you want to refer to an infix function without applying
any arguments, and there are also times when you want to use them as
prefix operators instead of infix. In both cases you must wrap the operator
in parentheses.

(+1) is the same addition function but with one argument applied, making
it return the next argument it’s applied to plus one:
Prelude> 1 + 2
Prelude> (+) 1 2
Prelude> (+1) 2

** 2.10 for quotients and remainders
(quot x y)*y + (rem x y) == x
(div x y)*y + (mod x y) == x

** 2.11 Evaluation
When we talk about reducing an expression, we’re talking about evaluating
the terms until it reaches its simplest form. Once a term has reached its
simplest form, we say that it is irreducible or finished evaluating. Usually,
we call this a value. Haskell uses a non-strict evaluation (sometimes called
“lazy evaluation”) strategy which defers evaluation of terms until they’re
forced by other terms referring to them.

** 2.12 Let and where
We can use let and where to introduce names for expressions.

printInc n = print plusTwo
where plusTwo = n + 2

same

printInc2 n = let plusTwo = n + 2
in print plusTwo

*** Intermission: Exercises

*** The lambdas beneath let expressions
Prelude> (\x -> x) 1
1

-- ((lambda (x) x) 1)
-- 1

** 2.13 Chapter Exercises
*** $ Operator
The ($) operator
is a convenience for when you want to express something with fewer pairs
of parentheses.
Example of ($) in some expressions:

Prelude> (2^) $ 2 + 2
16
Prelude> (2^) (2 + 2)
16
Prelude> (2^) 2 + 2
6

If you like, a way to understand ($) in words is: “evaluate everything to
the right of me first.”
Also note that you can stack up multiple uses of ($) in the same expression.
For example, this works:

Prelude> (2^) $ (+2) $ 3*2
256

But this does not:
Prelude> (2^) $ 2 + 2 $ (*30)
-- A rather long and ugly type error about trying to
-- use numbers as if they were functions follows.

We can see for ourselves why this code doesn’t make sense if we examine
the reduction steps.

** 2.14 Definitions
** 2.15 Follow-up resources


* Chapter 3
** 3.1 Printing strings
** 3.2 A first look at types


checking value's type in ghci:
Prelude> :t 'a'
'a' :: Char

** 3.3 Printing simple strings

Prelude> print "hello world!"
"hello world!"

*** printing commands discussed
print
putStrLn
putStr

*** paragraph The main function
*** String concatenation
*** Global versus local definitions
Here’s an example for review:

module GlobalLocal where
topLevelFunction :: Integer -> Integer
topLevelFunction x = x + woot + topLevelValue
where woot :: Integer
woot = 10

topLevelValue :: Integer
topLevelValue = 5

In the above, you could import and use topLevelFunction or
topLevelValue from another module. However, woot is effectively invisible
outside of topLevelFunction. The where and let clauses in Haskell intro-
duce local bindings or declarations. To bind or declare something means to
give an expression a name. You could pass around and use an anonymous
version of topLevelFunction manually, but giving it a name and reusing
it by that name is more pleasant and less repetitious. Also note we explic-
itly declared the type of woot in the where clause. This wasn’t necessary
(Haskell’s type inference would’ve figured it out fine), but it was done here
to show you how in case you need to.

*** Intermission: Exercises

** 3.4 Type signatures of concatenation functions
Everything after the :: is about our types, not our values.
*** Intermission: Exercises
** 3.5 An example of concatenation and scoping
** 3.6 More list functions
** 3.7 Chapter Exercises
** 3.8 Definitions


* new book

** 1.1 All you need is Lambda
finished all you need is lambda

* Chapter 4
** 4.1 Basic Datatypes
** 4.2 Anatomy of a data declaration
** 4.3 Numeric types

*** Integral
**** Int
has minimum and maximum
**** Integer
arbitrarily large

**** minBound maxBound functions
*** Fractional
**** Float
***** single precision
***** violates assumptions
***** generally, not for use in business applications

**** Double
***** twice as many bits as Float

**** Rational
***** arbitrarily precise
***** not as efficient as Scientific

**** Scientific
***** space efficient
***** almost arbitrary precision
***** exponent as Int
****** potential, though unlikely maximum limit

*** all are instances of typeclass Num
*** typeclasses add functionality to types
**** Num tepeclass provides + - * and other operators
**** any type that is instance of Num can be used with those operators
*** typeclass constraint =>
**** (/) :: Fractional a => a -> a -> a
**** The notation Fractional a => denotes a typeclass constraint
This type information is telling us that whatever type of number a turns
out to be, it must be a type that has an instance of the Fractional typeclass.

So (+) and other functions
from the Num typeclass can be used with Fractional numbers, but functions
from the Fractional typeclass cannot be used with all instances of Num


** 4.4 Comparing values

** 4.5 Tuples

** 4.6 Lists

** 4.7 Exercises

* continue on page 140
